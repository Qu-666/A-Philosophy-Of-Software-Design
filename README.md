# A-Philosophy-Of-Software-Design
架构设计哲学电子译本

简单的几句话：

经历了疫情，断断续续的持续了大约1年半的时间，阅读+翻译了本书，本书完美诠释了软件设计的本质--如何解决复杂性？围绕这个核心不断的抽丝剥茧，深入浅出。
通过阅读本书你将充分认识和理解什么是软件的设计，怎么做设计？

因为个人水平有限，专业述语较多，语言篇幅较大，可能翻译的不够准确，大家可以多多提供建议 To:（mail: qystar@live.cn）；感谢互联网的一些参考资料和英语大辞典~

本翻译读本不以任何商业为目的，只作为学习之用。


------------------------------------------------------------------------------------------------------------------------------------
目录
前言
1	介绍
	1.1	怎样使用本书
2	复杂性的本质
	2.1	复杂性的定义
	2.2	复杂性的症状
	2.3	复杂性的原因
	2.4	复杂性是递增的
	2.5	结论
3	工作中的代码是不充分的（瀑布/敏捷）
	3.1	战术编程
	3.2	战略编程
	3.3	投入多少？
	3.4	创业与投资
	3.5	结论
4	应该深入模块设计(接口应该非常简单)
    4.1	模块化设计
	4.2	接口里有什么？
	4.3	抽象
	4.4	深模块
	4.5	浅模块
	4.6	Classitis
	4.7	实例：Java 和 Unix I/O
	4.8	结论
5	信息的隐藏（和泄漏）
	5.1	信息的隐藏
	5.2	信息的泄漏
	5.3	时间的分解
	5.4	实例：HTTP 服务
	5.5	实例：太多的类
	5.6	实例：HTTP参数处理
	5.7	实例：HTTP响应中的默认值
	5.8	一个类中隐藏的信息
	5.9	Taking it too far
	5.10	结论
6	模块的通用性
	6.1	使类具有一定的通用性
	6.2	实例：为编辑器存储文本
	6.3	更多通用性的接口
	6.4	通用性导致更好的信息隐藏
	6.5	问自己一些问题
	6.6	结论
7	不同的层，不同的抽象
	7.1	方法传递
	7.2	什么时候可以复制接口？
	7.3	装饰者
	7.4	接口与实现
	7.5	变量传递
	7.6	结论
8	降低复杂度
	8.1	实例：类文本编辑器
	8.2	实例：参数配置
	8.3	太过头了
	8.4	结论
9	一起更好还是分开更好？
	9.1	如果信息是共享的则聚合起来
	9.2	如果它能简化接口则聚合起来
	9.3	聚合起来消除重复
	9.4	单独通用的和专用的代码
	9.5	实例：插入光标和选择
	9.6	实例：用户记录日志的单独类
	9.7	实例：编辑器的撤消机制
	9.8	拆分和合并方法
	9.9	结论
10	定义未知的错误
10.1	为什么异常会增加复杂性
10.2	异常太多
10.3	定义未知的错误
10.4	实例：在windows中删除文件
10.5	实例：Java substring 方法
10.6	掩藏异常
10.7	异常聚合
10.8	崩溃了吗？
10.9	设计未知的特殊情况
10.10	Talking is too far
10.11	结论
11	设计多个方案
12	为什么写注释？四个原因
12.1	好的代码本身就是文档
12.2	我没有时间写注释
12.3	注释过时，容易误导
12.4	我看到所有的注释都毫无价值
12.5	写好注释的益处
13	注释应该描述那些不明显的事情在代码中
13.1	选择约定
13.2	不要重复代码
13.3	低级的注释增加精确度
13.4	高级的注释增强直觉
13.5	接口文档
13.6	注释实现：什么和为什么，而不是如何
13.7	跨模块设计决策
13.8	结论
13.9	对13.5节的问题回答
14	命名
14.1	实例：坏的命名引起的漏洞
14.2	创建图像
14.3	名字应该要准确
14.4	名字使用的一致性
14.5	一个不同的观点：Go风格引导
14.6	结论
15	先写注释
15.1	延迟的注释不是好注释
15.2	先写注释
15.3	注释是一种设计工具
15.4	早期的注释是有趣的注释
15.5	早期的注释贵吗？
15.6	结论
16	修改已经存在的（老的）代码
16.1	保持战略编程
16.2	注释维护：将注释保留在代码附近  
16.3	注释属于代码，而不是提交日志
16.4	注释维护：避免重复
16.5	注释维护：检查差异
16.6	更高级别注释更易于维护
17	一致性
17.1	一致性示例
17.2	确保一致性
17.3	走得太远
17.4	结论
18	代码应该是易于理解的
18.1	使代码变得显而易见
18.2	使代码变得不那么明显 
18.3	结论
19	软件趋势/动向
19.1	面向对象编程和继承
19.2	敏捷开发
19.3	单元测试
19.4	测试驱动开发
19.5	设计模式
19.6	Getters和setters
19.7	结论
20	性能设计
20.1	如何考虑性能
20.2	修改前的度量
20.3	围绕关键路径设计
20.4	例如：RAMCloud缓冲区
20.5	结论
21	结论
设计原则概要
关于作者
